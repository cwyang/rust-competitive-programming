var searchIndex={};
searchIndex["rust_competitive_programming"] = {"doc":"","i":[[0,"binary_search","rust_competitive_programming","",null,null],[8,"BinarySearch","rust_competitive_programming::binary_search","ソート済の列に対して二分法で\"境目\"を探します。",null,null],[10,"lower_bound","","",0,[[["t"],["self"]],["usize"]]],[10,"upper_bound","","",0,[[["t"],["self"]],["usize"]]],[10,"split_by","","",0,[[["t"],["self"]]]],[0,"factorization","rust_competitive_programming","",null,null],[5,"min_factors","rust_competitive_programming::factorization","「k を割る最小の素数」をエラトステネスのふるいの要領で 2 以上 n 未満の全ての k について計算します。 #…",null,[[["usize"]],[["usize"],["vec",["usize"]]]]],[0,"fenwick_tree","rust_competitive_programming","",null,null],[3,"FenwickTree","rust_competitive_programming::fenwick_tree","",null,null],[11,"new","","長さ `n` の列を作り、初期値 `e` で埋めます。雰囲気は `let mut a = vec![e; n];`…",1,[[["usize"],["t"]],["self"]]],[11,"add","","`k` 番目の値に `x` を足します。`k` は 0-indexed です。`a[k] += x;`",1,[[["self"],["usize"],["t"]]]],[11,"sum","","区間和を計算します。`range` が `l..r` だとして `a[l..r].iter().sum();`…",1,[[["usize"],["self"],["range",["usize"]]],["t"]]],[0,"grid","rust_competitive_programming","",null,null],[3,"Adjacent","rust_competitive_programming::grid","グリッドグラフで現在位置の周辺を走査したいときに使えます。",null,null],[11,"new","","隣接 4 方向を走査する例です。 # Examples `use…",2,[[["i"],["usize"]],["self"]]],[0,"next_permutation","rust_competitive_programming","",null,null],[8,"NextPermutation","rust_competitive_programming::next_permutation","",null,null],[10,"next_permutation","","",3,[[["self"]],["bool"]]],[0,"rolling_hash","rust_competitive_programming","",null,null],[3,"RollingHash","rust_competitive_programming::rolling_hash","Rolling Hash です。O(文字列長) の前計算をしたうえで、部分文字列のハッシュ値を O(1) で計算します。",null,null],[11,"new","","",4,[[],["self"]]],[11,"get","","`range` が指す範囲の部分文字列のハッシュ値を返します。",4,[[["usize"],["self"],["range",["usize"]]],["u64"]]],[11,"connect","","2 つの文字列を連結したときのハッシュ値を返します。",4,[[["usize"],["self"],["u64"]],["u64"]]],[0,"union_find","rust_competitive_programming","",null,null],[3,"UnionFind","rust_competitive_programming::union_find","Union Find はグラフの連結成分を管理します。",null,null],[11,"new","","グラフの頂点数 `n` を渡します。",5,[[["usize"]],["unionfind"]]],[11,"unite","","頂点 `i` の属する連結成分と頂点 `j` の属する連結成分をつなげます。",5,[[["self"],["usize"]]]],[11,"get_size","","頂点 `i` の属する連結成分のサイズ (頂点数) を返します。",5,[[["self"],["usize"]],["usize"]]],[11,"same","","頂点 `i` と頂点 `j` が同じ連結成分に属するかどうかを返します。",5,[[["self"],["usize"]],["bool"]]],[11,"leaders","","各連結成分の代表元をベクタで返します。",5,[[["self"]],[["usize"],["vec",["usize"]]]]],[0,"util","rust_competitive_programming","",null,null],[0,"z_algorithm","","",null,null],[5,"z_algorithm","rust_competitive_programming::z_algorithm","",null,[[],[["usize"],["vec",["usize"]]]]],[11,"from","rust_competitive_programming::fenwick_tree","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"vzip","","",1,[[],["v"]]],[11,"from","rust_competitive_programming::grid","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"into_iter","","",2,[[],["i"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"vzip","","",2,[[],["v"]]],[11,"from","rust_competitive_programming::rolling_hash","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"vzip","","",4,[[],["v"]]],[11,"from","rust_competitive_programming::union_find","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"vzip","","",5,[[],["v"]]],[11,"next","rust_competitive_programming::grid","",2,[[["self"]],["option"]]]],"p":[[8,"BinarySearch"],[3,"FenwickTree"],[3,"Adjacent"],[8,"NextPermutation"],[3,"RollingHash"],[3,"UnionFind"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);